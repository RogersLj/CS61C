### 计算机中的浮点数



如果有n位的bit

我们可以表示2^n个不同的东西

无符号整数

有符号整数 - 补码



那么那些非常大的数和非常小的数呢

还有那些小数呢



十进制下的小数点

123.456

二进制的小数

10.1010

六位

最大的数11.1111

最小00.0000



固定小数点

加法，小数点不会发生变化

乘法，因为结果和乘数的小数点位置不一样，所以我们需要知道小数点在哪里，如果用固定小数点的方式去表示，肯定是不方便的



### 浮点

小数点的位置不是固定的

0.1640625



...000000.0010101000000....

前面和后面都是一串0，我们需要存储的应该是中间我们关心的部分，但是如果用固定的小数点，我们就不得不存下那些浪费空间的0，

我们需要存下10101，这些能量最集中的部分，我们数据真正有用的部分，然后告诉计算机小数点在哪里



我们需要一个这种表示浮点的办法，首先告诉这部分真实的数据是多少，然后再告诉小数点的位置



科学计数法

十进制里，×10，小数点向右移动一个位



规范化

非规范化



二进制里的科学计数法

我们将再计算机里以这种形式存储数据，我们将这些数叫做浮点数



![image-20211129135452967](https://raw.githubusercontent.com/RogersLj/Image/master/PicGo/image-20211129135452967.png)



我们为什么要存储1前面的一串0，所以我们没有必要

同时我们也知道开始的第一位一定是1，根据规范化的科学计数法表示

我们可以存储1.，小数点之后的部分，尾数



![image-20211129135851118](https://raw.githubusercontent.com/RogersLj/Image/master/PicGo/image-20211129135851118.png)



### IEEE

![image-20211129140007004](https://raw.githubusercontent.com/RogersLj/Image/master/PicGo/image-20211129140007004.png)



先来看第一个问题，数字0，明显是没有前置1的，

所以我们需要用一个特殊的表示方法来表示数字0

这里我们将指数全部为0，尾数为0表示为数字0

但是因为我们的符号可以为正负

所以0有两个



关于指数为什么要用移码表示

![image-20211129140422655](https://raw.githubusercontent.com/RogersLj/Image/master/PicGo/image-20211129140422655.png)



有些计算机没有专门处理浮点数的处理器

127的偏移量

![image-20211129140641359](https://raw.githubusercontent.com/RogersLj/Image/master/PicGo/image-20211129140641359.png)



统一了浮点数的表示标准

不同计算机都可以对浮点数进行运算



### 特殊的数的表达

在数学里面，除了这些我们能够用数字表示出来的数，还有一些我们用符号代替的数，还记得吗，那就是正负无穷



所以我们希望在这种表示里，正负无穷不会导致溢出，而是用一串比特来表示这两个数

同时我们需要保证，正无穷与一个数的和是正无穷，负无穷和一个数的和也是负无穷



在之后会看到

对于能够表示的最大的浮点数，再增加一个比特之后就会翻转到无穷大

所以对于无穷大的表示，我们让指数全部为1，也就是指数为255，来表示无穷大



所以我们可以看到

最大的浮点数表示为

1 1 1 1 1 1 1 0	1 1 1 .。。。 1 1 1 

指数为254，尾数全为1

这个时候如果尾数再多1

那么就会翻转为

1 1 1 1 1 1 1 1 	000 .。。。000

这个数就是无穷大了



指数和尾数都为0来表示0，但是我们有两种0的表示



指数1 ~ 254， 尾数为任意数，卡哇伊用来表示所有的浮点数



所以我们还有集中情况没有讨论：

- 指数为0， 尾数不为零
- 指数255， 尾数不为零



在计算机中，我们知道一定的位数下能够表示的数的个数是一定的，所以我们不应该浪费任何一种比特序列表示



在数学里我们还有一种常见的情况

0 / 0

任何数除以零

这是未定义的，结果不存在



所以我们也需要为这种结果一种表示方法

#### 指数255， 尾数不为零

表示Not a Number - NaN



为什么这种表示的方法是有效的

因为我们希望任何一个NaN，和一个数进行运算，得到的结果都应该是NaN



### 非规范化表示

![image-20211129143005223](https://raw.githubusercontent.com/RogersLj/Image/master/PicGo/image-20211129143005223.png)



最小的浮点数是多少？

我门知道指数1 ~ 254

所以指数最小为1

尾数为0时



第二小的数字

尾数最低位为1



我们可以看到

b - a = 2 ^ (-149)

a - 0 = 2 ^ (-126)



0到最小的浮点数a之间还有一个很大的gap

我们还可以利用起来表示更多的数



我们可以看到这个 2 ^ (-126) 是怎么来的

是因为我们规范表示下1造成的



所以如果我们需要用非规范的表示方法来表示这个gap里面的数

#### 指数为0， 尾数不为零



这种情况下我们没有了前置1，取而代之的是前置0

同时这个情况下，因为指数始终为0，我们需要首先规定一个指数值，我们规定的指数为-126



在这种表示下，我们能够表示的最小的浮点数是

0 0 0 0 0 0 0 0 	0000...0001

表示的数为

1 * 2 ^ (-23) * 2 ^ (-126) = 2 ^ (-149)

第二小的 数是

0 0 0 0 0 0 0 0 	0000...0010

1 * 2 ^ (-22) * 2 ^ (-126) = 2 ^ (-148) = 2 * 2 ^ (-149)



所以我们这就把0到a之间的gap平均分了

浮点数之间的间隔等于从b开始的间隔

能够表达最大的数



每一步的宽度，相邻数与数之间的间隔，和指数有关

每一次指数加一，步幅都会翻倍



所以我们有很多非常小的数

然后我们也可以很快就到达大数字



所以数轴上所有浮点数之间的步幅不是都相同的



![image-20211129144652733](https://raw.githubusercontent.com/RogersLj/Image/master/PicGo/image-20211129144652733.png)



我们看一下这些特殊的数之间怎么相互衔接的



首先是一些非常小的数，我们用非规范化的形式表示，然后当

规范化再前进就是无穷大

无穷大再大就是NaN





步幅相同的gap里都有2^23个数

但是因为步幅是每次翻倍的

所以

2 4 .。。 

表示的数是2的倍数之间以步幅为大小的数





浮点数的加法不遵循结合律

因为在上面我们发现不是所有的小数都可以被浮点数表示出来

所以一些小数存在计算机里可能就不是真实值

